//----------------------------------------------------------------------------
// 文件名：SystemTick.c
//----------------------------------------------------------------------------
// 功能:  定义了系统滴答时钟
//
//----------------------------------------------------------------------------
// 说明：1. 系统滴答时钟的使用方式类似于操作系统的中的滴答时钟，用于设置软件定时器、
//		 模块的时序控制等,系统中的其他部分的时序控制和延时都和其节拍频率有关
//		2.需要使用CpuTimer0
//----------------------------------------------------------------------------
// 引脚定义：无
// 芯片：	TMS230F28335
//----------------------------------------------------------------------------
// 作者： 刘亚彬
// 创建日期: 2017年1月12日
// 修改日期：
// 版本：v0.1
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//include
//-----------------------------------------------------------------------------
#include "SystemTick.h"

//-----------------------------------------------------------------------------
//函数声明
//-----------------------------------------------------------------------------
Uint16 TickInit(void);
Uint16 TickChangeState(State state);
Uint16 TickScanCallback(void);

//-----------------------------------------------------------------------------
//variables
//-----------------------------------------------------------------------------
SystemTick mySystemTick;

Uint16 TickEnd = 0;			//一个滴答完成标志位

//-----------------------------------------------------------------------------
// 函数名：void UseSystemTick(void)
//-----------------------------------------------------------------------------
// 函数功能： 初始化mySystemTick成员变量
//-----------------------------------------------------------------------------
// 函数说明：并不是所有的编译器都支持有选择的初始化成员变量，因此定义一个函数专门用
//			于对mySystemTick的部分成员变量进行初始化。使用mySystemTick之前必须要
//			调用此函数。
//-----------------------------------------------------------------------------
// 输入参数：	无
// 输出参数： 	无
//-----------------------------------------------------------------------------
void UseSystemTick(void)
{
	mySystemTick.State = Disable;
	mySystemTick.TickPrd = 1;
	mySystemTick.TickCnt = 0;

	mySystemTick.Init = TickInit;
	mySystemTick.ChangeState = TickChangeState;
	mySystemTick.ScanCallback = TickScanCallback;
}

//-----------------------------------------------------------------------------
// 函数名：Uint16 TickInit(void)
//-----------------------------------------------------------------------------
// 函数功能： 初始化SystemTick
//-----------------------------------------------------------------------------
// 函数说明：需要使用的CpuTimer0
//-----------------------------------------------------------------------------
// 输入参数：	无
// 输出参数： 	0 -> 初始化完成,1 -> 定时器已被使用
//-----------------------------------------------------------------------------
Uint16 TickInit(void)		//系统滴答初始化
{
	if(myHardwarePool.bit.CpuTimer0)
		return 1;
	ConfigCpuTimer(&CpuTimer0,150,mySystemTick.TickPrd*1000.0);

	PieCtrlRegs.PIEIER1.bit.INTx7 = 1;		//TINT0在PIE组1
	IER |= M_INT1;    //开启CPU中断 组1
	return 0;
}

//-----------------------------------------------------------------------------
// 函数名：Uint16 TickChangeState(State state)
//-----------------------------------------------------------------------------
// 函数功能： 改变系统滴答时钟的状态
//-----------------------------------------------------------------------------
// 函数说明：
//-----------------------------------------------------------------------------
// 输入参数：	无
// 输出参数： 	0 -> 初始化完成,1 -> 定时器已被使用,2 -> 输入参数错误
//-----------------------------------------------------------------------------
Uint16 TickChangeState(State state)		//改变状态
{
	if(state == Enable)
	{
		if(myHardwarePool.bit.CpuTimer0)
			return 1;
		ReloadCpuTimer0();
		StartCpuTimer0();		//启动定时器

		myHardwarePool.bit.CpuTimer0 = 1;
	}
	else if(state == Disable)
	{
		StopCpuTimer0();
		myHardwarePool.bit.CpuTimer0 = 0;
	}
	else
		return 2;
	return 0;
}

//-----------------------------------------------------------------------------
// 函数名：Uint16 TickScanCallback(void)
//-----------------------------------------------------------------------------
// 函数功能： 滴答扫描回调函数
//-----------------------------------------------------------------------------
// 函数说明：需要在主程序中循环扫描，每过一个定时节拍会进行相应的处理
//-----------------------------------------------------------------------------
// 输入参数：	无
// 输出参数： 	0 -> 处理完一次数据,1 -> 定时周期未到
//-----------------------------------------------------------------------------
Uint16 TickScanCallback(void)		//滴答扫描回调
{
	static Uint16 _rs232TxEndCnt = 0;
	static Uint16 _rs232RxLastNum = 0;
	static Uint16 _rs232RcCnt = 0;

	static Uint16 _rs485TxEndCnt = 0;
	static Uint16 _rs485RxLastNum = 0;
	static Uint16 _rs485RcCnt = 0;

//用于控制滴答时钟的代码，不用动
	if(TickEnd == 0)
		return 1;
	TickEnd = 0;

//添加自定义的定时代码

// 485测试
//	static Uint16 send485Cnt = 0;		//485发送数据计数器
//	send485Cnt++;
//	if(send485Cnt >= 1000)		//每1s发送一次数据
//	{
//		RS485.SendBuffer[0] = 'H';
//		RS485.SendBuffer[1] = 'E';
//		RS485.SendBuffer[2] = 'L';
//		RS485.SendBuffer[3] = 'L';
//		RS485.SendBuffer[4] = 'O';
//		RS485.SendBuffer[5] = '\n';
//		RS485.SendData(6);
//
//		send485Cnt = 0;
//	}

//	Fpga写入命令测试
//	static Uint16 flipFlag = 0;
//
//	if(flipFlag)
//	{
//		myFpgaDriver.SpwmOutEnable(Enable);
//		myFpgaDriver.SCRSwitchOn(Enable);
//		myFpgaDriver.RecInputSW(Enable);
//		flipFlag = 0;
//	}
//	else
//	{
//		myFpgaDriver.SpwmOutEnable(Disable);
//		myFpgaDriver.SCRSwitchOn(Disable);
//		myFpgaDriver.RecInputSW(Disable);
//		flipFlag = 1;
//	}

//用于控制通讯时序的代码，不用动
	if(RS232.Flag.bit.SendEnd)		//232一帧数据全部扔到缓冲区
	{
		_rs232TxEndCnt++;
		if(_rs232TxEndCnt >= SEND_END_TICK)	//发送完成
		{
			RS232.Flag.bit.SendEmptyFlag = 1;		//发送缓冲区空

			_rs232TxEndCnt = 0;						//复位所有变量状态，以便下次运行
			RS232.Flag.bit.SendEnd = 0;
		}

	}

	if(RS232.Flag.bit.RecData)		//接收到数据了
	{
		if(_rs232RxLastNum == RS232.RecNum)		//两个节拍间隔之间没有收到新的数据
		{
			_rs232RcCnt++;
			if(_rs232RcCnt >= RECF_END_TICK)
			{
				RS232.Flag.bit.RecFrameFlag = 1;		//接收到一帧数据

				_rs232RxLastNum = 0;				//复位所有变量状态，以便下次运行
				RS232.Flag.bit.RecData = 0;
				_rs232RcCnt = 0;
			}
		}
		else
			_rs232RxLastNum = RS232.RecNum;
	}

	if(RS485.Flag.bit.SendEnd)		//485一帧数据全部扔到缓冲区
	{
		_rs485TxEndCnt++;
		if(_rs485TxEndCnt >= RS485_SEND_END_TICK)	//发送完成
		{
			RS485.Flag.bit.SendEmptyFlag = 1;		//发送缓冲区空

			_rs485TxEndCnt = 0;						//复位所有变量状态，以便下次运行
			RS485.Flag.bit.SendEnd = 0;
			RS485_RXENABLE;							//使能485接收
		}
	}

	if(RS485.Flag.bit.RecData)		//接收到数据了
	{
		if(_rs485RxLastNum == RS485.RecNum)		//两个节拍间隔之间没有收到新的数据
		{
			_rs485RcCnt++;
			if(_rs485RcCnt >= RS485_RECF_END_TICK)
			{
				RS485.Flag.bit.RecFrameFlag = 1;		//接收到一帧数据

				_rs485RxLastNum = 0;				//复位所有变量状态，以便下次运行
				RS485.Flag.bit.RecData = 0;
				_rs485RcCnt = 0;
			}
		}
		else
			_rs485RxLastNum = RS485.RecNum;
	}

	return 0;
}

//-----------------------------------------------------------------------------
//下面为所用到的对应中断程序
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// 函数名：interrupt void CpuTimer0_ISR(void)
//-----------------------------------------------------------------------------
// 函数功能： CpuTimer0中断
//-----------------------------------------------------------------------------
// 函数说明： 	用于系统滴答时钟
//-----------------------------------------------------------------------------
// 输入参数：	无
// 输出参数： 	无
//-----------------------------------------------------------------------------
interrupt void CpuTimer0_ISR(void)
{
	TickEnd = 1;

	CpuTimer0Regs.TCR.bit.TIF = 1;		//清除标志位
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}






